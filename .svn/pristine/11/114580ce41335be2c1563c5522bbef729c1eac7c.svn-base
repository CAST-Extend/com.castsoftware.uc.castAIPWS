package com.castsoftware.jenkins.CastAIPWS;

import hudson.EnvVars;
import hudson.Extension;
import hudson.Launcher;
import hudson.RelativePath;
import hudson.XmlFile;
import hudson.model.BuildListener;
import hudson.model.AbstractBuild;
import hudson.model.AbstractProject;
import hudson.tasks.BuildStepDescriptor;
import hudson.tasks.Builder;
import hudson.util.FormValidation;
import hudson.util.ListBoxModel;

import java.io.IOException;
import java.lang.reflect.Type;
import java.rmi.RemoteException;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.logging.ConsoleHandler;
import java.util.logging.LogManager;
import java.util.logging.Logger;

import javax.servlet.ServletException;
import javax.xml.rpc.ServiceException;
import javax.xml.soap.SOAPException;

import jenkins.model.Jenkins;
import net.sf.json.JSONObject;

import org.apache.commons.httpclient.methods.GetMethod;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.filter.ElementFilter;
import org.jdom.input.SAXBuilder;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.QueryParameter;
import org.kohsuke.stapler.Stapler;
import org.kohsuke.stapler.StaplerRequest;

import com.castsoftware.batch.CastWebService;
import com.castsoftware.batch.CastWebServiceServiceLocator;
import com.castsoftware.exception.HelperException;
import com.castsoftware.jenkins.CastAIPWS.util.AawsBlock;
import com.castsoftware.jenkins.CastAIPWS.util.AdBlock;
import com.castsoftware.jenkins.CastAIPWS.util.ArchiveBlock;
import com.castsoftware.jenkins.CastAIPWS.util.BackupBlock;
import com.castsoftware.jenkins.CastAIPWS.util.Constants;
import com.castsoftware.jenkins.CastAIPWS.util.OptimizeBlock;
import com.castsoftware.jenkins.CastAIPWS.util.PublishBlock;
import com.castsoftware.jenkins.CastAIPWS.util.RaBlock;
import com.castsoftware.jenkins.CastAIPWS.util.RsBlock;
import com.castsoftware.jenkins.CastAIPWS.util.RsvBlock;
import com.castsoftware.jenkins.CastAIPWS.util.Utils;
import com.castsoftware.jenkins.util.EnvTemplater;
import com.castsoftware.jenkins.util.PublishEnvVarAction;
import com.castsoftware.profiles.ConnectionProfile;
import com.castsoftware.util.CastUtil;
import com.castsoftware.util.VersionInfo;
import com.castsoftware.vps.ValidationProbesService;
import com.castsoftware.webservice.RemoteHelper;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;

public class CastAIPBuilder extends Builder
{
	private final String dmtWebServiceAddress;
	private final String cmsWebServiceAddress;
	private final String appName;
	private final String versionName;
	private final String referenceVersion;
	private final String castMSConnectionProfile;
	private final String schemaPrefix;
	private final String aadSchemaName;

	private final boolean backup;
	private final boolean da;
	private final boolean ad;
	private final boolean ra;
	private final boolean rs;
	private final boolean archive;
	private final boolean rav;
	private final boolean publish;
	private final boolean optimize;

	// private final String snapshotName;
	// private final String captureDate;
	private final String workFlow;

	// Fields in config.jelly must match the parameter names in the
	// "DataBoundConstructor"
	@DataBoundConstructor
	public CastAIPBuilder(String dmtWebServiceAddress, String cmsWebServiceAddress, String appName,
			String referenceVersion, String versionName, String castMSConnectionProfile, BackupBlock backupBlock,
			AdBlock daBlock, AdBlock adBlock, RaBlock raBlock, RsBlock rsBlock, RsvBlock ravBlock,
			PublishBlock publishBlock, ArchiveBlock archiveBlock, OptimizeBlock optimizeBlock, String workFlow,
			String schemaPrefix, String aadSchemaName)
	{
		this.dmtWebServiceAddress = dmtWebServiceAddress;
		this.cmsWebServiceAddress = cmsWebServiceAddress;
		this.appName = appName;
		this.versionName = versionName;
		this.referenceVersion = referenceVersion;
		this.castMSConnectionProfile = castMSConnectionProfile;
		this.schemaPrefix = schemaPrefix;
		this.aadSchemaName = aadSchemaName;
		this.workFlow = workFlow;

		// Use alternate Web Service for CMS
		// if (aawsBlock != null) {
		// this.aaws = true;
		// this.cmsWebServiceAddress = aawsBlock.getCmsWebServiceAddress();
		// } else {
		// this.aaws = false;
		// this.cmsWebServiceAddress = dmtWebServiceAddress;
		// }

		// Publish snapshot
		if (backupBlock != null) {
			this.backup = true;
		} else {
			this.backup = false;
		}

		// Deliver Code
		if (daBlock != null) {
			this.da = true;
		} else {
			this.da = false;
		}

		// Accept Delivery
		if (adBlock != null) {
			this.ad = true;
		} else {
			this.ad = false;
		}

		// Run Analysis
		if (raBlock != null) {
			this.ra = true;
		} else {
			this.ra = false;
		}

		// Run Snapshot
		if (rsBlock != null) {
			this.rs = true;
		} else {
			this.rs = false;
		}

		// Run Analysis Validation
		if (ravBlock != null) {
			this.rav = true;
		} else {
			this.rav = false;
		}

		// Publish snapshot
		if (publishBlock != null) {
			this.publish = true;
		} else {
			this.publish = false;
		}

		// Publish snapshot
		if (optimizeBlock != null) {
			this.optimize = true;
		} else {
			this.optimize = false;
		}

		// Archive Delivery
		if (archiveBlock != null) {
			this.archive = true;
		} else {
			this.archive = false;
		}
	}

	private Boolean checkWebServiceCompatibility(String version)
	{
		return Constants.wsVersionCompatibility.equals(version);
	}

	public String getDmtWebServiceAddress()
	{
		return dmtWebServiceAddress;
	}

	public String getCmsWebServiceAddress()
	{
		String retVal = "";
		if (cmsWebServiceAddress == null || cmsWebServiceAddress.isEmpty()) {
			retVal = dmtWebServiceAddress;
		} else {
			retVal = cmsWebServiceAddress;
		}
		return retVal;
	}

	public String getAadSchemaName()
	{
		return aadSchemaName;
	}

	public String getSchemaPrefix()
	{
		return schemaPrefix;
	}

	public String getAppName()
	{
		return appName;
	}

	public String getVersionName()
	{
		return versionName;
	}

	public String getReferenceVersion()
	{
		return referenceVersion;
	}

	public String getCastMSConnectionProfile()
	{
		return castMSConnectionProfile;
	}

	public boolean isBackup()
	{
		return backup;
	}

	public boolean isDa()
	{
		return da;
	}

	public boolean isAaws()
	{
		return da;
	}

	public boolean isOptimize()
	{
		return optimize;
	}

	public boolean isAd()
	{
		return ad;
	}

	public boolean isRa()
	{
		return ra;
	}

	public boolean isRs()
	{
		return rs;
	}

	public boolean isRav()
	{
		return rav;
	}

	public boolean isArchive()
	{
		return archive;
	}

	public boolean isPublish()
	{
		return publish;
	}

	public String getVersionNameWithTag(Date date, EnvVars envVars)
	{
		String s = versionName.replace("[TODAY]", Constants.dateFormatVersion.format(date));
		EnvTemplater jEnv = new EnvTemplater(envVars);
		s = jEnv.templateString(s);

		return s;
	}

	/**
	 * Pattern p = Pattern.compile("\\[([A-za-z0-9_]+)\\]"); Matcher m =
	 * p.matcher(s);
	 * 
	 * while (m.find()) { value = envVars.get(m.group(1)); if (value != null) s
	 * = s.replace(m.group(), value); }
	 **/
	// return s;
	// }

	public String getWorkFlow()
	{
		return workFlow;
	}

	// private String getCastTimeStamp() throws ServiceException
	// {
	// String castDate=null;
	// if (envVars != null)
	// {
	// castDate = envVars.get(Constants.CAST_DATE);
	// }
	// if (castDate == null)
	// {
	// throw new ServiceException("CAST_DATE is not set");
	// }
	// return castDate;
	// }

	// public FormValidation
	// doTestConnection(@QueryParameter("webServiceAddress") final String
	// webServiceAddress) throws IOException, ServletException
	// {
	// try {
	// return FormValidation.ok(String.format("Success (%s)",
	// RemoteHelper.getVersionInfo(webServiceAddress).toString()));
	//
	// } catch (HelperException e) {
	// return FormValidation.error(String.format("%s: %s",
	// e.getClass().getName(), e.getMessage()));
	// }
	// }

	public ListBoxModel doFillAppNameItems(@QueryParameter("dmtWebServiceAddress") final String webServiceAddress)
	{
		ListBoxModel m = new ListBoxModel();

		try {
			Collection<String> apps = RemoteHelper.listApplications(webServiceAddress);

			for (String app : apps) {
				m.add(app);
			}

		} catch (HelperException e) {
			return m;
		}
		return m;
	}

	public ListBoxModel doFillCastMSConnectionProfileItems(
			@QueryParameter("cmsWebServiceAddress") final String webServiceAddress)
	{
		ListBoxModel m = new ListBoxModel();

		List<String> logNames = (List<String>) LogManager.getLogManager().getLoggerNames();

		try {
			Collection<ConnectionProfile> cpList = RemoteHelper.listConnectionProfiles(webServiceAddress);

			for (ConnectionProfile cp : cpList) {
				m.add(cp.getName(), cp.getName());
			}

		} catch (HelperException e) {
			return m;
		}
		return m;
	}

	@SuppressWarnings("rawtypes")
	public boolean publishVariables(AbstractBuild build, BuildListener listener, String castDate) throws IOException,
			InterruptedException
	{
		boolean rslt = true;
		Date dateForToday;
		try {
			EnvVars envVars = build.getEnvironment(listener);
			dateForToday = Utils.convertCastDate(castDate).getTime();

			String snapshotName = "Computed on " + Constants.dateFormatVersion.format(dateForToday);

			build.addAction(new PublishEnvVarAction(Constants.CAST_DATE, castDate));
			build.addAction(new PublishEnvVarAction(Constants.DMT_WEB_SERVICE_ADDRESS, getDmtWebServiceAddress()));
			build.addAction(new PublishEnvVarAction(Constants.CMS_WEB_SERVICE_ADDRESS, getCmsWebServiceAddress()));
			build.addAction(new PublishEnvVarAction(Constants.APPLICATION_NAME, getAppName()));
			build.addAction(new PublishEnvVarAction(Constants.VERSION_NAME,
					getVersionNameWithTag(dateForToday, envVars)));
			build.addAction(new PublishEnvVarAction(Constants.AAD_SCHEMA_NAME, getAadSchemaName()));
			build.addAction(new PublishEnvVarAction(Constants.SCHEMA_PREFIX, getSchemaPrefix()));
			build.addAction(new PublishEnvVarAction(Constants.CONNECTION_PROFILE, getCastMSConnectionProfile()));
			build.addAction(new PublishEnvVarAction(Constants.SNAPSHOT_NAME, snapshotName));

			build.addAction(new PublishEnvVarAction(Constants.WORK_FLOW, getWorkFlow()));
			build.addAction(new PublishEnvVarAction(Constants.REFERENCE_VERSION, getReferenceVersion()));

			//build flags
			build.addAction(new PublishEnvVarAction(Constants.RUN_BACKUP, Boolean.toString(isBackup())));
			build.addAction(new PublishEnvVarAction(Constants.RUN_BACKUP, Boolean.toString(isBackup())));
			
//			private final boolean da;
//			private final boolean ad;
//			private final boolean ra;
//			private final boolean rs;
//			private final boolean archive;
//			private final boolean rav;
//			private final boolean publish;
//			private final boolean optimize;

			
			
			rslt = Utils.validateBuildVariables(build, listener);

		} catch (ParseException e) {
			listener.error("Unable to publish CAST Enviroment Variables: %s", e.getMessage());
			return false;
		}
		return rslt;
	}

	@SuppressWarnings("rawtypes")
	@Override
	public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) throws IOException,
			InterruptedException
	{
		int taskId;
		int returnCode;
		int feedbackCounter;
		long startTime = System.nanoTime();

		EnvVars envVars = build.getEnvironment(listener);
		int startAt;
		try {
			startAt = Integer.parseInt(envVars.get(Constants.START_AT));
		} catch (NumberFormatException e) {
			startAt = 0;
		}
		String castDate = envVars.get(Constants.CAST_DATE);
		if (castDate==null || castDate.isEmpty()) {
			castDate = Constants.castDateFormat.format(new Date());
		}
		if (!publishVariables(build, listener, castDate)) {
			return false;
		}
		listener.getLogger().println("****CAST Application Inteligence Platform****");

		listener.getLogger().println(String.format("START_AT: %d", startAt));
		listener.getLogger().println(String.format("CAST_DATE: %s", castDate));

//		String logString;
//		Type collectionType = new TypeToken<Collection<String>>()
//		{
//		}.getType();
//		Collection<String> tmp;
//		List<String> logLines;
//
//		int logIndex = 0;

		boolean failBuild = getWorkFlow().trim().toLowerCase().equals("no");

//		Gson gson = new Gson();

		listener.getLogger().println(String.format("DMT Web Service Address:  %s", getDmtWebServiceAddress()));
		listener.getLogger().println(String.format("CMS Web Service Address:  %s", getCmsWebServiceAddress()));

		CastWebServiceServiceLocator cbwsl = new CastWebServiceServiceLocator();
		cbwsl.setCastWebServicePortEndpointAddress(getCmsWebServiceAddress());
		try {
			CastWebService cbws = cbwsl.getCastWebServicePort();

			Date dateForToday = Constants.castDateFormat.parse(castDate);
			String versionNameWithTag = getVersionName().replace("[TODAY]",
					Constants.dateFormatVersion.format(dateForToday));

			if (!Utils.validateWebServiceVersion(getCmsWebServiceAddress(), listener)) {
				return false;
			}
			String appId = cbws.getApplicationUUID(appName);

			for (Builder b : getBuilderList(getJobTaskList(build, listener))) {
				if (!b.perform(build, launcher, listener)) {
					return false || failBuild;
				}
			}

		} catch (ServiceException | RemoteException | ParseException | InterruptedException | HelperException
				| UnsupportedOperationException e) {
			listener.getLogger().println(
					String.format("Interrupted after: %s\n%s: %s",
							CastUtil.formatNanoTime(System.nanoTime() - startTime), e.getClass().getName(),
							e.getMessage()));
			return false || failBuild;
		}
		return true;
	}

	private List<Builder> getBuilderList(List<Element> taskList)
	{
		List<Builder> builders = new ArrayList<Builder>();

		if (backup && Utils.canRunTask(taskList, CastAIPCSSBackupBuilder.class, this.getClass())) {
			builders.add(new CastAIPCSSBackupBuilder());
		} else if (backup && builders.size() > 0) {
			return builders;
		}

		if (da && Utils.canRunTask(taskList, CastAIPDeliverBuilder.class, this.getClass())) {
			builders.add(new CastAIPDeliverBuilder());
		} else if (da && builders.size() > 0) {
			return builders;
		}

		if (ad && Utils.canRunTask(taskList, CastAIPAcceptBuilder.class, this.getClass())) {
			builders.add(new CastAIPAcceptBuilder());
		} else if (ad && builders.size() > 0) {
			return builders;
		}

		if (ra && Utils.canRunTask(taskList, CastAIPAnalyzeBuilder.class, this.getClass())) {
			builders.add(new CastAIPAnalyzeBuilder());
		} else if (ra && builders.size() > 0) {
			return builders;
		}

		if (rs && Utils.canRunTask(taskList, CastAIPSnapshotBuilder.class, this.getClass())) {
			builders.add(new CastAIPSnapshotBuilder());
		} else if (rs && builders.size() > 0) {
			return builders;
		}

		if (rav && Utils.canRunTask(taskList, CastAIPValidationBuilder.class, this.getClass())) {
			builders.add(new CastAIPValidationBuilder());
		} else if (rav && builders.size() > 0) {
			return builders;
		}

		if (publish && Utils.canRunTask(taskList, CastAIPPublishBuilder.class, this.getClass())) {
			builders.add(new CastAIPPublishBuilder());
		} else if (publish && builders.size() > 0) {
			return builders;
		}

		if (optimize && Utils.canRunTask(taskList, CastAIPOptimizeDatabaseBuilder.class, this.getClass())) {
			builders.add(new CastAIPOptimizeDatabaseBuilder());
		} else if (optimize && builders.size() > 0) {
			return builders;
		}

		if (archive && Utils.canRunTask(taskList, CastAIPArchiveDeliveryBuilder.class, this.getClass())) {
			builders.add(new CastAIPArchiveDeliveryBuilder());
		} else if (archive && builders.size() > 0) {
			return builders;
		}

		builders.add(new CastAIPFinalBuilder());
		return builders;
	}

	// Overridden for better type safety.
	// If your plugin doesn't really define any property on Descriptor,
	// you don't have to do this.
	@Override
	public DescriptorImpl getDescriptor()
	{
		return (DescriptorImpl) super.getDescriptor();
	}

	/**
	 * Descriptor for {@link CastAIPBuilder}. Used as a singleton. The class is
	 * marked as public so that it can be accessed from views.
	 *
	 * <p>
	 * See
	 * <tt>src/main/resources/hudson/plugins/hello_world/CastDMTBuilder/*.jelly</tt>
	 * for the actual HTML fragment for the configuration screen.
	 */
	@Extension
	// This indicates to Jenkins that this is an implementation of an extension
	// point.
	public static final class DescriptorImpl extends BuildStepDescriptor<Builder>
	{
		private boolean useDMT;

		public DescriptorImpl()
		{
			load();
		}

		// public FormValidation doCheckCaptureDate(@QueryParameter String
		// value)
		// throws IOException, ServletException {
		// if (value.equals("[TODAY]"))
		// return FormValidation.ok();
		// try {
		// new SimpleDateFormat("MM/dd/yyyy HH:mm:ss",
		// Locale.ENGLISH).parse(value);
		// return FormValidation.ok();
		// } catch (ParseException e) {
		// return
		// FormValidation.error("Expected format is \"MM/dd/yyyy HH:mm:ss\"");
		// }
		// }

		@SuppressWarnings("rawtypes")
		public boolean isApplicable(Class<? extends AbstractProject> aClass)
		{
			// Indicates that this builder can be used with all kinds of project
			// types
			return true;
		}

		/**
		 * This human readable name is used in the configuration screen.
		 */
		public String getDisplayName()
		{
			return "CAST AIP: Configuration";
		}

		public FormValidation doTestConnection(
				@QueryParameter("dmtWebServiceAddress") final String dmtWebServiceAddress,
				@QueryParameter("cmsWebServiceAddress") String cmsWebServiceAddress) throws IOException,
				ServletException
		{
			boolean ok = true;
			if (dmtWebServiceAddress.isEmpty()) {
				return FormValidation.error("Delivery Web Service Address must have a value!");
			} else if (cmsWebServiceAddress.replaceAll("\t", "").isEmpty()) {
				cmsWebServiceAddress = dmtWebServiceAddress;
			}

			StringBuffer returnMsg = new StringBuffer();
			try {
				VersionInfo dvi = RemoteHelper.getVersionInfo(dmtWebServiceAddress);
				returnMsg.append(String.format("Delivery Address Success (%s)\n", dvi.toString()));
			} catch (HelperException e) {
				returnMsg.append(String.format("Delivery Address Error %s\n", e.getMessage()));
				ok = false;
			}
			try {
				VersionInfo dvi = RemoteHelper.getVersionInfo(cmsWebServiceAddress);
				if (dvi.getVersion().equals(Constants.wsVersionCompatibility)) {
					returnMsg.append(String.format("Analysis Address Success (%s)\n", dvi.toString()));
				} else {
					returnMsg.append(String.format("WARNING ****** CAST Batch Web Service Version is not supported by this plugin ******* (%s)\n", dvi.toString()));
					ok = false;					
				}
			} catch (HelperException e) {
				returnMsg.append(String.format("Analysis Address Error %s", e.getMessage()));
				ok = false;
			}

			if (ok) {
				return FormValidation.ok(returnMsg.toString());
			} else {
				return FormValidation.error(returnMsg.toString());
			}

		}

		public ListBoxModel doFillReferenceVersionItems(
				@QueryParameter("dmtWebServiceAddress") final String webServiceAddress,
				@QueryParameter("appName") final String appName)
		{
			ListBoxModel m = new ListBoxModel();

			try {
				Collection<String> versions = RemoteHelper.listVersions(webServiceAddress, appName);

				for (String version : versions) {
					m.add(version);
				}

			} catch (HelperException e) {
				return m;
			}
			return m;
		}

		public ListBoxModel doFillCastMSConnectionProfileItems(
				@QueryParameter("dmtWebServiceAddress") final String dmtWebServiceAddress,
				@QueryParameter("cmsWebServiceAddress") final String cmsWebServiceAddress)
		{
			Logger log = LogManager.getLogManager().getLogger(Logger.GLOBAL_LOGGER_NAME);
			log.addHandler(new ConsoleHandler());
			log.entering(getClass().getName(), String.format(
					"doFillCastMSConnectionProfileItems (dmtWebServiceAddress<%s>,cmsWebServiceAddress<%s>)",
					dmtWebServiceAddress, cmsWebServiceAddress));
			
			ListBoxModel m = new ListBoxModel();

			try {
				String webServiceAddress;
				if (cmsWebServiceAddress == null || cmsWebServiceAddress.isEmpty()) {
					webServiceAddress = dmtWebServiceAddress;
				} else {
					webServiceAddress = cmsWebServiceAddress;
				}
				Collection<ConnectionProfile> cpList = RemoteHelper.listConnectionProfiles(webServiceAddress);
				for (ConnectionProfile cp : cpList) {
					m.add(cp.getName(), cp.getName());
				}

			} catch (HelperException e) {
				return m;
			}
			return m;
		}

		public ListBoxModel doFillAppNameItems(@QueryParameter("dmtWebServiceAddress") final String webServiceAddress)
		{
			ListBoxModel m = new ListBoxModel();

			try {
				Collection<String> apps = RemoteHelper.listApplications(webServiceAddress);

				for (String app : apps) {
					m.add(app);
				}

			} catch (HelperException e) {
				return m;
			}
			return m;
		}

		@Override
		public boolean configure(StaplerRequest req, JSONObject formData) throws FormException
		{
			useDMT = formData.getBoolean("useDMT");
			save();
			return super.configure(req, formData);
		}

		public boolean getUseDMT()
		{
			return useDMT;
		}
	}

	private List<Element> getJobTaskList(AbstractBuild build, BuildListener listener) throws IOException,
			InterruptedException
	{
		List<Element> retList = new ArrayList<Element>();

		EnvVars envVars = build.getEnvironment(listener);
		String jobName = envVars.get("JOB_NAME");
		AbstractProject thisJob = null;

		for (AbstractProject prj : Jenkins.getInstance().getAllItems(AbstractProject.class)) {
			if (prj.getDisplayName().equalsIgnoreCase(jobName)) {
				thisJob = prj;
				break;
			}
		}
		XmlFile config = thisJob.getConfigFile();
		SAXBuilder builder = new SAXBuilder();

		Document document;
		try {
			document = builder.build(config.getFile());
			Element bldrs = Utils.findElement(document.getRootElement(), "builders");
			if (bldrs != null) {
				List<Element> bldrList = bldrs.getChildren();
				for (Element el : bldrList) {
					String name = el.getName();
					if (name.contains(".CastAIPWS.")) {
						retList.add(el);
					}
				}
			}

		} catch (JDOMException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return retList;
	}

}
